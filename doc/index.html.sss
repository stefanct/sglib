<HTML>

<HEAD>

<TITLE>SGLIB - Reference</TITLE>

</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<br>
<center>
<h1>SGLIB - Reference Manual</h1>
</center>

<br>

<h2>Content</h2>

<ul>
<li><a href="#about">About</a>
<li><a href="#concepts">Concepts</a>
<li><a href="#api0">Application Interface - level 0</a>
<ul>
<li><a href="#array_api0">Arrays</a>
<li><a href="#list_api0">Linked Lists</a>
<li><a href="#sorted_list_api0">Sorted Linked Lists</a>
<li><a href="#dl_list_api0">Double Linked Lists</a>
<li><a href="#bin_tree_api0">Binary Trees</a>
</ul>
<li><a href="#api1">Application Interface - level 1</a>
<ul>
<li><a href="#array_api1">Arrays</a>
<li><a href="#hashed_container_api1">Hashed Containers</a>
<li><a href="#list_api1">Linked Lists</a>
<li><a href="#sorted_list_api1">Sorted Linked Lists</a>
<li><a href="#dl_list_api1">Double Linked Lists</a>
<li><a href="#rbtree_api1">Red-Black Trees</a>
</ul>
<li><a href="#examples">Examples</a>
<ul>
<li><a href="#array_exam">Arrays</a>
<li><a href="#hashed_container_exam">Hashed Containers</a>
<li><a href="#list_exam">Linked Lists</a>
<li><a href="#sorted_list_exam">Sorted Linked Lists</a>
<li><a href="#dl_list_exam">Double Linked Lists</a>
<li><a href="#rbtree_exam">Red-Black Trees</a>
</ul>
</ul>


<br><br>
<br><br>

<a name="about"></a>

<h2> About Sglib </h2>

<em>SGLIB</em> stands for <em>Simple Generic Library</em> and it
consists of single header file 
written in C programming language.
The header file <code>sglib.h</code> provides generic implementation of most
common algorithms for arrays, lists, sorted lists and red-black trees.
Implementation of double linked lists and hashed tables is envisaged.
Also suggestions for new useful functionalities are welcomed.
The library is generic and it does not define its own data
structures. Rather it acts on existing user defined data structures
via a generic interface.  It also does not allocate or deallocate any
memory and does not depend on any particular memory management.  In
case od several datatypes, sglib even does not impose its own data
representation. For example, sglib list routines can be applied to any
user defined structure containing a pointer to the same
structure as its field.

<p>
All algorithms are implemented in form of macros parametrized by the
type of data structure and comparator function (or comparator
macro). Several further generic parameters such as the name of 'next'
field for linked lists may be required for some algorithms and data
structures.

<p>
Sglib offers access to algorithms in two level user interface. A
<em>level - 0</em> interface is simply a collection of useful macros.
If you do not like large macros or you afraid introduction of symbol
clashes after macro expansions you can use a <em>level - 1</em>
interface. This interface generates legal C functions for each particular
type. Those functions can be called from the main program without
worrying about unwanted effects due to macro expansions.

<p>
You can always use level - 0 interface. You can use level - 1 interface
only if your base type is named by a single identifier, or if you have
defined a typedef for it. It is a question of taste whether you decide
to use one of two interfaces. It seems that you get the most
advantages by using both interfaces in the same time. You can do this
without worrying about implementation clashes, the level - 1
inplementation are just wrappers to level - 0 interface.  However, few
functions using recursion (red-black trees for example) are
implemented exclusively in level - 1 interface. 

<p>
During the design and implementation of sglib we have followed following rules:
<ul>
<li>Efficiency. Resulting code must be as efficient as if it was
        specialized code
<li>Simplicity. No special tool is needed for generic constructions.
<li>In order to avoid conflicts with user symbols, each defined macro and 
        function starts by 'SGLIB_' and 'sglib_' prefix respectively.
<li>In order to avoid situation when actual macro parameter conflicts with 
        symbol defined within macro, all names defined within macros start and 
        finish with underscore character.
<li>Each occurence of macro parameter giving an expression is always used
        enclosed into supplementary parentheses.
</ul>



<br><br>
<a name="concepts"></a>

<h2> Sglib - Concepts </h2>


<a name=comparator></a>

<h3>Comparator</h3>

A <em>comparator</em> is a function (or macro)
taking two elements and returning an integer value, the value is 
respectively a negative number, zero or a positive number for cases
when the first parameter is less than, equal, or greater than the second.
For example the standard C function <em>strcmp</em> is a string 
<em>comparator</em> which can be directly
used in sglib. Also a macro
<pre>
#define SGLIB_NUMERIC_COMPARATOR(x, y) ((int)((x) - (y)))
</pre>
is a comparator for integers numbers. By the way, the macro 
<code>SGLIB_NUMERIC_COMPARATOR</code> with this definition 
is predefined in sglib
and you can use it withount need of your own redefinitions.


<a name=subcomparator></a>

<h3>Subcomparator</h3>


A <a href="#comparator">comparator</a> which is induced from 
another comparator in a way that it
makes several elements equal while otherwise preserving the original
ordering is called a <em>subcomparator</em>. More formally, if <code>cmp</code>
is a comparator and <code>subcmp</code> is its subcomparator, then:
<br>
<br>
 &nbsp; <code>cmp(x,y) &lt; 0</code> implies <code>subcmp(x,y) &lt;= 0</code>
<br>
and
<br>
 &nbsp; <code>cmp(x,y) > 0</code> implies <code>subcmp(x,y) >= 0</code>
<br>
<br>
Subcomparators are used in iterators to iterate over such part 
of a container which is equal to a given element. For example, let's take that we have a red black tree
of strings ordered lexicographically.
We can define a subcomparator comparing only the first letter
of strings:
<pre>
#define strsubcmp(x, y) (x[0] - y[0])
</pre>
Using this subcomparator we can iterate over all strings 
starting with the same letter.




<a name="elem_exchanger"></a>

<h3>Array elem_exchanger and simultaneous sorting of multiple arrays</h3>

An <em>elem_exchanger</em> is a function (or macro) performing
exchange of two elements in an array.
It takes following four parameters: the type of array elements, 
the array on which it operates, and two indexes of elements to exchange. 
For example the following macro:
<pre>
#define SGLIB_ARRAY_ELEMENTS_EXCHANGER(type, a, i, j) {type tmp;tmp=a[i];a[i]=a[j];a[j]=tmp;}
</pre>
is an <em>elem_exchanger</em> usable by sglib. By the way, the macro 
<code>SGLIB_ARRAY_ELEMENTS_EXCHANGER</code> with this definition 
is predefined in the sglib and you can use in implementations of your own 
<em>elem_exchanger</em>s.
An <em>elem_exchanger</em> can be used to parametrize sorting
algorithms. The motivation is that 
in many projects, several arrays keep related informations. 
Elemens of different arrays having the same index are related to each other
and they form a single record. For example, one can represent a phone annuary by
keeping person names in one array (say <em>name</em>) and corresponding phone
numbers in another array (say <em>phoneNumbers</em>). In this representation the person 
<code>name[i]</code>
has the phone number <code>phoneNumber[i]</code>. 
If you decide to sort your annuary alphabetically by names,
you have to make corresponding reordering also on numbers. 
<p>
Sglib modifies arrays exclusively by
using an <em>elem_exchanger</em>.
You can use your own <em>elem_exchanger</em> as parameter for sorting
algorithms. Your implementation can 
simultaneously exchange elements in several arrays, 
and hence make sorting to act on multiple related arrays. 
For example, continuing the annuary example, we can define the following
<em>elem_exchanger</em>:
<pre>
#define ANNUARY_EXCHANGER(type, a, i, j) {\
  SGLIB_ARRAY_ELEMENTS_EXCHANGER(char *, name, i, j);\
  SGLIB_ARRAY_ELEMENTS_EXCHANGER(int, phoneNumber, i, j);\
}
</pre>
and use it as parameter of a sorting macro. For example we can sort the first 1000 elements 
of the annuary by the following command:
<pre>
SGLIB_ARRAY_QUICK_SORT(char*, name, 1000, strcmp, ANNUARY_EXCHANGER);
</pre>

<br><br>


<A name="container"></a>

<h3>Container</h3>

A <em>container</em> data structure is any data structure containing 
elements. This is for example an array, list, sorted list, red-black tree, etc.


<A name="linked_list"></a>

<h3>Linked lists</h3>

A linked list is any C structure containing a pointer to the next
element. The structure is entirely defined by the user, 
sglib does not provide any default implementation.
Following code defines several lists on which sglib can operate:

<center>
<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>

struct myintlist {
&nbsp;    int value;
&nbsp;    struct myintlist *next;
};

struct history {
&nbsp;    int order;
&nbsp;    struct historyelem *h;
&nbsp;    // ... any other records
&nbsp;    struct history *previous;
};

// you can even consider special trees as linked lists
struct mytreenode {
&nbsp;    int nodetype;
&nbsp;    union nodeinformations node;
&nbsp;    struct mytrenode **subtrees;
};

</pre>
</td></tr>
</table>
</center>

Sglib does not contain
any allocation or freeing of memory, so your program is responsible
for allocating/freeing of each element of the list. 
Sglib provides macros for ordering and
maintaining such lists. Macros, such
as insert and delete only affect the <a
href="#next_element">next</a> field of elements, so that the element is correctly
inserted/deleted into/from the list.


<A name="next_element"></a>

<h3>Linked list next element parameter</h3> 

The <em>next</em> parameter of sglib macros is the name of the field
pointing to the next element of the <a href="#linked_list">list</a>. 
For example for structures defined in the previous section
this parameter will be respectively words: 
<code>next</code>, <code>previous</code> and <code>subtrees[1]</code>.




<A name="comparator_equality"></a>
<A name="pointer_equality"></a>

<h3>Pointer equality versus comparator equality</h3> 

Sglib distinguishes two notions of equality. Two elements are said <em>pointer equal</em> if they
are the same object in the memory and hence they are referenced by the same pointer. 
Two elements are said <em>comparator equal</em> if the
<a href="#comparator">comparator</a> applied on those elements returns zero.
In other words, the comparator equality tests the equality of keys. You can have several
elements with the same key (hence comparator equal) in a data structure such as list, but only
one occurence of each element with the same pointer (otherwise a cyclic data structure occurs).

<p>
The difference between pointer and comparator equality remains the
difference between <code>==</code> and <code>equals</code> operators in Java language (with
the difference that in sglib user has to implement its own comparator).

<A name="pointer_member"></a>
<A name="comparator_member"></a>

<h3>Pointer and comparator equal membership</h3>

Distinction between <a href="#comparator_equality">pointer and comparator equality</a> 
generates two notions of membership in a <a href="#container">container</a> data structure. 
We say that an element <code>E</code> 
is a <em>pointer equal member</em> of a container if it is physically 
part of the data structure, i.e. if the container contains the pointer to <code>E</code>.
We say that an element <code>E</code> 
is a <em>comparator equal member</em>, if the container contains
an element which is <a href="#comparator_equality">comparator equal</a> to <code>E</code>.
In other words, an element is a <em>comparator equal member</em> of a container 
if the container contains an element with the same key. Note that if an element
is a <em>pointer equal member</em> then it is also a <em>comparator equal member</em>.





<A name="dl_linked_list"></a>

<h3>Double Linked lists</h3>

A double linked list is any C structure containing two pointers interpreted respectively as the previous and the next
elements of the list. The structure is entirely defined by the user, 
sglib does not provide any default implementation.
Following code defines several double linked lists on which sglib can operate:

<center>
<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>

struct mydoublelinkedlist {
&nbsp;    int value;
&nbsp;    struct mydoublelinkedlist *previous, *next;
};

struct history {
&nbsp;    int order;
&nbsp;    struct historyelem *h;
&nbsp;    // ... any other records
&nbsp;    struct history *up, *down;
};

</pre>
</td></tr>
</table>
</center>

Sglib provides macros for ordering and
maintaining such lists. The list is passed to sglib using a pointer to any of its member. 
Sglib than operates on the whole list accessible via 
<a href="#dl_previous_element">previous</a> and <a href="#dl_next_element">next</a> 
fields.
Macros, such
as insert and delete only affect the <a href="#dl_previous_element">previous</a> and <a href="#dl_next_element">next</a> 
fields of elements, the rest of the structure is kept intact.


<A name="dl_previous_element"></a>
<A name="dl_next_element"></a>

<h3>Previous and next parameters of macros for double linked lists</h3> 

The <em>previous</em> and <em>next</em> parameters of sglib macros are names of fields
pointing respectively to the previous and to the next elements of a <a href="#dl_linked_list">double linked list</a>. 
For example, in the case of the first structure defined in the previous section
those parameters will be <code>previous</code> and <code>next</code>. For the second structure
those parameters will be <code>up</code> and <code>down</code>.






<a name="bintree"></a>

<h3>Binary trees</h3>

A <em>binary tree</em> is any structure type containing two pointers to subtrees. 
The structure is entirely defined by the user, 
sglib does not provide any default implementation.
Following code defines several implementations of binary trees on which sglib can operate:

<center>
<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>

struct myTreeNode {
&nbsp;    int key;
&nbsp;    struct myTreeNode *left;
&nbsp;    struct myTreeNode *right;
};

struct generalTree {
&nbsp;    struct nodeInfo onfo;
&nbsp;    struct generalTree **subtrees;
};

// you can have a structure which is a tree and a list at the same time
struct listAndTree {
&nbsp;    int key;
&nbsp;    struct listAndTree *left_ptr;
&nbsp;    struct listAndTree *right_ptr;
&nbsp;    struct listAndTree *next_ptr;
};

</pre>
</td></tr>
</table>
</center>


<A name="left_right_element"></a>

<h3>Left and right parameters of tree macros</h3>

The <em>left</em> and <em>right</em> parameters of sglib macros are the names of fields
pointing respectively to the left and right subtrees of the given <a href="#bintree">tree</a> node.
For example for structures defined in the previous section
those parameter will be respectively pairs of words: 
<code>left, right</code> then <code>subtrees[0], subtrees[1]</code> and finally
<code>left_ptr, right_ptr</code>.



<a name="rbtree"></a>

<h3>Red-Black Trees</h3>

A <em>red-black tree</em> is a balanced <a href="#bintree">binary tree</a> with (at least) one
bit of additional information storing the color of each node. Nodes in red-black trees
can be colored either red or black. Usualy those two colors are represented by 0 and 1
respectively. The structure defining a node in red-black tree is entirely defined by the user, 
sglib does not provide any default implementation.
Our implementation of red-black trees uses recursion, 
this is why red-black trees are available only in level-1 interface.
Following code defines several examples of structures which can be organized 
as red-black trees:

<center>
<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>

struct myTreeNode {
&nbsp;    int key;
&nbsp;    char color;
&nbsp;    struct myTreeNode *left;
&nbsp;    struct myTreeNode *right;
};

struct TreeWithOneColorBit {
&nbsp;    struct {
&nbsp;      unsigned key:31;
&nbsp;      unsigned blackLabel:1;
&nbsp;    } bits;
&nbsp;    struct TreeWithOneColorBit *left;
&nbsp;    struct TreeWithOneColorBit *right;
};

</pre>
</td></tr>
</table>
</center>



<A name="rb_color"</a>

<h3>Color parameter for red-black tree macros</h3>

The <em>color</em> parameter of macros operating on red-black trees is the name of the field
containing information about the color of the node.
For example for structures defined in the previous section
this parameter will be <code>color</code> and <code>bits.blackLabel</code>.


#SPARSE_SHELL_SCRIPT_EXECUTE
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
################################                  API LEVEL 0            ##################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END

<br><br>
<br><br>
<a name="api0"></a>

<h2>API: level 0</h2>

The level 0 application interface is simply a collection of useful
generic macros. Those macros are in general parametrized by some kind
of C type (probably a C structure) and this is why they can not be
implemented by C functions.

<p> 

By convention, names of all macros start by SGLIB_ prefix. Then
goes the identification of the data structure on which the macro
operates and finaly the action performed by the macro.

<p> In the design of macros we tried to make macros as generic as
possible.  This sometimes leads to parameters which may seems useless.
However, because macro expansion is done in compile time and the
number of macro parameters does not affect the efficiency of the code, 
we thing that additional parameters do not matter.

<br><br>


#SPARSE_SHELL_SCRIPT_EXECUTE
###########################################################################################################
################################                  ARRAYS             ######################################
###########################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END

<br><br>

<a name="array_api0"></a>


<h2>Array sorting API: level 0</h2>

<table border=1 CELLPADDING="10" CELLSPACING="0">


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_ARRAY_SINGLE_QUICK_SORT</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_ARRAY_SINGLE_QUICK_SORT(type, a, max, comparator)</b></code>
<br>
<br>
sort a single array using quicksort.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_single_array_sort_parameters='
<dd><code>type</code> - the type of array elements.
<dd><code>a</code> - the array to sort.
<dd><code>max</code> - the number of elements in the array.
<dd><code>comparator</code> - a <a href="#comparator">comparator</a> used to compare elements.'
echo "${sglib_single_array_sort_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_ARRAY_SINGLE_HEAP_SORT</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_ARRAY_SINGLE_HEAP_SORT(type, a, max, comparator)</b></code>
<br>
<br>
sort a single array using heapsort.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_single_array_sort_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_ARRAY_QUICK_SORT</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_ARRAY_QUICK_SORT(type, a, max, comparator, elem_exchanger)</b></code>
<br>
<br>
sort possibly multiple arrays using quicksort.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_array_sort_parameters=${sglib_single_array_sort_parameters}'
<dd><code>elem_exchanger</code> - an <a href="#elem_exchanger">elem_exchanger</A> used to exchange two elements in the array.'
echo "${sglib_array_sort_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_ARRAY_HEAP_SORT</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_ARRAY_HEAP_SORT(type, a, max, comparator, elem_exchanger)</b></code>
<br>
<br>
sort possibly multiple arrays using heapsort.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_array_sort_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_ARRAY_BINARY_SEARCH</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_ARRAY_BINARY_SEARCH(type, a, start_index, end_index, key, comparator, found, result_index)</b></code>
<br>
<br>
find the key in a sorted array using binary search.
<dd><dl>
<dt><b>Parameters:</b>
<dd><code>type</code> - the type of array elements.
<dd><code>a</code> - the array.
<dd><code>start_index</code> - the starting index, it is the smallest index possibly containing the <code>key</code>.
<dd><code>end_index</code> - the ending index, it is the largest index possibly containing the <code>key</code> increased by one.
<dd><code>key</code> - the element to search.
<dd><code>comparator</code> - a <a href="#comparator">comparator</a> used to compare elements.
<dd><code>found</code> - (output) is set to non-zero if the key was found, to zero otherwise.
<dd><code>result_index</code> - (output) is set to the index of the element equal to the key. If there is no such element, than <code>result_index</code> is set to the index where the key can be inserted while preserving the array ordering.
</dd>
</td></tr>

</table>

#SPARSE_SHELL_SCRIPT_EXECUTE
###############################################################################################################
################################             LISTS API LEVEL 0           ######################################
###############################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END

<br><br>

<a name="list_api0"></a>

<h2>Lists API: level 0</h2>

<table border=1 CELLPADDING="10" CELLSPACING="0">



<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_LIST_ADD</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_LIST_ADD(type, list, elem, next)</b></code>
<br>
<br>
add an element to a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_list_type_parameter='
<dd><code>type</code> - the type of list elements.
'
sglib_list_next_parameter='
<dd><code>next</code> - the name of the field pointing to the <a href="#next_element">next</a> element of the list.
'
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to add.
'
echo "${sglib_list_next_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_LIST_ADD_IF_NOT_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_LIST_ADD_IF_NOT_MEMBER(type, list, elem, comparator, next, member)</b></code>
<br>
<br>
add an element to a list if there is no <a href="#comparator_equality">comparator equal</a> element inside.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_list_comparator_next_parameters='
<dd><code>comparator</code> - the <a href="#comparator">comparator</a> used to compare elements.
'"${sglib_list_next_parameter}"
sglib_list_add_member_parameter='
<dd><code>member</code> - (output) NULL, if the <code>elem</code> has been added to the list, otherwise this variable is set to the member of the <code>list</code> which is equal to <code>elem</code>.
'
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to add.
'
echo "${sglib_list_comparator_next_parameters}"
echo "${sglib_list_add_member_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_LIST_CONCAT</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_LIST_CONCAT(type, first, second, next)</b></code>
<br>
<br>
concatenate two lists by appending the second at the end of the first.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>first</code> - the first list.
<dd><code>second</code> - the second list.
'
echo "${sglib_list_next_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_LIST_DELETE</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_LIST_DELETE(type, list, elem, next)</b></code>
<br>
<br>
delete an element from a list. The element must be a <a href="#pointer_member">pointer equal member</a> of the list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to delete.
'
echo "${sglib_list_next_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_LIST_DELETE_IF_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_LIST_DELETE_IF_MEMBER(type, list, elem, comparator, next, member)</b></code>
<br>
<br>
remove a <a href="#comparator_equality">comparator equal</a> element from a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_list_delete_member_parameter='
<dd><code>member</code> - (output) NULL, if the <code>elem</code> was not inside the <code>list</code>, otherwise this variable is set to the deleted element.
'
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to delete.
'
echo "${sglib_list_comparator_next_parameters}"
echo "${sglib_list_delete_member_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_LIST_IS_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_LIST_IS_MEMBER(type, list, elem, next, result)</b></code>
<br>
<br>
determine whether an element is a <a href="#pointer_member">pointer member</a> of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to search.
'
echo "${sglib_list_next_parameter}"
echo '
<dd><code>result</code> - (output) set to zero, if <code>elem</code> is not memebr of the <code>list</code>, non-zero otherwise.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_LIST_FIND_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_LIST_FIND_MEMBER(type, list, elem, comparator, next, result)</b></code>
<br>
<br>
determine whether there is a <a href="#comparator_equality">comparator equal</a> element in a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to search.
'
echo "${sglib_list_comparator_next_parameters}"
echo '
<dd><code>result</code> - (output) set to the resulting member. This variable is NULL if the <code>elem</code> has not been found in the <code>list</code>.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_LIST_LEN</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_LIST_LEN(type, list, next, result)</b></code>
<br>
<br>
compute the length of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
'
echo "${sglib_list_next_parameter}"
echo '
<dd><code>result</code> - (output) the length of the <code>list</code>.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_LIST_MAP_ON_ELEMENTS</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_LIST_MAP_ON_ELEMENTS(type, list, var, next, command)</b></code>
<br>
<br>
apply a command on all elements of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>var</code> - the variable which will run through each element of the list.
'
echo "${sglib_list_next_parameter}"
echo '
<dd><code>command</code> - any (possibly composed) statement of the C language. In the statement you can use the variable <code>var</code> (third parameter of the macro) going through all elements of the list.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_LIST_REVERSE</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_LIST_REVERSE(type, list, next)</b></code>
<br>
<br>
reverse a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list to reverse.
'
echo "${sglib_list_next_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_LIST_SORT</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_LIST_SORT(type, list, comparator, next)</b></code>
<br>
<br>
sort a list using mergesort.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list to sort
'
echo "${sglib_list_comparator_next_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


</table>


#SPARSE_SHELL_SCRIPT_EXECUTE
######################################################################################################################
################################             SORTED LISTS API LEVEL 0           ######################################
######################################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END

<br><br>

<a name="sorted_list_api0"></a>

<h2>Sorted Lists API: level 0</h2>

<table border=1 CELLPADDING="10" CELLSPACING="0">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_SORTED_LIST_ADD</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_SORTED_LIST_ADD(type, list, elem, comparator, next)</b></code>
<br>
<br>
insert an element into a sorted list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list where to insert the new element.
<dd><code>elem</code> - the element to insert.
'
echo "${sglib_list_comparator_next_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_SORTED_LIST_ADD_IF_NOT_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_SORTED_LIST_ADD_IF_NOT_MEMBER(type, list, elem, comparator, next, member)</b></code>
<br>
<br>
insert an element into a sorted list if there is no <a href="#comparator_equality">comparator equal</a> element inside.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list where to add the element.
<dd><code>elem</code> - the element to add.
'
echo "${sglib_list_comparator_next_parameters}"
echo "${sglib_list_add_member_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_SORTED_LIST_DELETE</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_SORTED_LIST_DELETE(type, list, elem, next)</b></code>
<br>
<br>
delete an element from a sorted list. The element must be a <a href="#pointer_member">pointer equal member</a> of the list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list where to delete the element.
<dd><code>elem</code> - the element to delete. It must be a <a href="#pointer_member">pointer equal member</a> of the <em>list</em>.
'
echo "${sglib_list_comparator_next_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_SORTED_LIST_DELETE_IF_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_SORTED_LIST_DELETE_IF_MEMBER(type, list, elem, comparator, next, member)</b></code>
<br>
<br>
remove a <a href="#comparator_equality">comparator equal</a> element from a sorted list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list where to delete the element.
<dd><code>elem</code> - the element to delete.
'
echo "${sglib_list_comparator_next_parameters}"
echo "${sglib_list_delete_member_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_SORTED_LIST_IS_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_SORTED_LIST_IS_MEMBER(type, list, elem, comparator, next, result)</b></code>
<br>
<br>
determine whether an element is a <a href="#pointer_member">pointer member</a> of a sorted list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list to search.
<dd><code>elem</code> - the element to search.
'
echo "${sglib_list_comparator_next_parameters}"
echo '
<dd><code>result</code> - (output) set to zero, if the <code>elem</code> is not member of the <code>list</code>. Non-zero otherwise.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_SORTED_LIST_FIND_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_SORTED_LIST_FIND_MEMBER(type, list, elem, comparator, next, result)</b></code>
<br>
<br>
determine whether an element is a <a href="#comparator_member">comparator member</a> of a sorted list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list to search.
<dd><code>elem</code> - the element to search.
'
echo "${sglib_list_comparator_next_parameters}"
echo '
<dd><code>result</code> - (output) set to the resulting member. This variable is NULL if the <code>elem</code> has not been found in the <code>list</code>.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_SORTED_LIST_FIND_MEMBER_OR_PLACE</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_SORTED_LIST_FIND_MEMBER_OR_PLACE(type, list, elem, comparator, next, comparator_result, member_ptr)</b></code>
<br>
<br>
determine whether an element is a <a href="#comparator_member">comparator member</a> of a sorted list, if not, find 
the place where to insert it. 
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list where to search the element.
<dd><code>elem</code> - the element to search.
'
echo "${sglib_list_comparator_next_parameters}"
echo '
<dd><code>comparator_result</code> - (output) the last <code>comparator</code> result. This is zero if the <code>element</code> was present in the <code>list</code>, non-zero otherwise.
<dd><code>member_ptr</code> - (output) the place where to insert <code>elem</code>. It is the pointer to the pointer which will be set to <code>elem</code> by insertion. If <code>comparator_result</code> is zero, then this is the pointer to the pointer to the element equal to <code>elem</code>.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_SORTED_LIST_LEN</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_SORTED_LIST_LEN(type, list, next, result)</b></code>
<br>
<br>
compute the length of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
'
echo "${sglib_list_next_parameter}"
echo '
<dd><code>result</code> - (output) variable set to the length of the <code>list</code>.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_SORTED_LIST_MAP_ON_ELEMENTS</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_SORTED_LIST_MAP_ON_ELEMENTS(type, list, var, next, command)</b></code>
<br>
<br>
apply a command on all elements of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>var</code> - the variable which will run through each element of the list.
'
echo "${sglib_list_next_parameter}"
echo '
<dd><code>command</code> - any (possibly composed) statement of the C language. In the statement you can use the variable <code>var</code> (third parameter of the macro) going through all elements of the list.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


</table>


#SPARSE_SHELL_SCRIPT_EXECUTE
###############################################################################################################
################################  DOUBLE LINKED LISTS API LEVEL 0           ###################################
###############################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END

<br><br>

<a name="dl_list_api0"></a>

<h2>Double Linked Lists API: level 0</h2>

<table border=1 CELLPADDING="10" CELLSPACING="0">



<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_ADD</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_ADD(type, list, elem, previous, next)</b></code>
<br>
<br>
add an element to a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_dl_list_type_parameter='
<dd><code>type</code> - the type of list elements.
'
sglib_dl_list_previous_next_parameter='
<dd><code>previous</code> - the name of the field pointing to the <a href="#dl_previous_element">previous</a> element of the list.
<dd><code>next</code> - the name of the field pointing to the <a href="#dl_next_element">next</a> element of the list.
'
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to add.
'
echo "${sglib_dl_list_previous_next_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_ADD_BEFORE</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_ADD_BEFORE(type, list, elem, previous, next)</b></code>
<br>
<br>
add an element to a list. <code>Elem</code> will be inserted before the element pointed by <code>list</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list (also specifying the place where to insert the new element).
<dd><code>elem</code> - the element to add.
'
echo "${sglib_dl_list_previous_next_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_ADD_AFTER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_ADD_AFTER(type, list, elem, previous, next)</b></code>
<br>
<br>
add an element to a list. <code>Elem</code> will be inserted after the element pointed by <code>list</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list (also specifying the place where to insert the new element).
<dd><code>elem</code> - the element to add.
'
echo "${sglib_dl_list_previous_next_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_ADD_IF_NOT_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_ADD_IF_NOT_MEMBER(type, list, elem, comparator, previous, next, member)</b></code>
<br>
<br>
add an element to a list if there is no <a href="#comparator_equality">comparator equal</a> element inside.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_dl_list_comparator_next_parameters='
<dd><code>comparator</code> - the <a href="#comparator">comparator</a> used to compare elements.
'"${sglib_dl_list_previous_next_parameter}"
sglib_dl_list_add_member_parameter='
<dd><code>member</code> - (output) NULL, if the <code>elem</code> has been added to the list, otherwise this variable is set to the member of the <code>list</code> which is equal to <code>elem</code>.
'
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to add.
'
echo "${sglib_dl_list_comparator_next_parameters}"
echo "${sglib_dl_list_add_member_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_ADD_BEFORE_IF_NOT_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_ADD_BEFORE_IF_NOT_MEMBER(type, list, elem, comparator, previous, next, member)</b></code>
<br>
<br>
add an element to a list if there is no <a href="#comparator_equality">comparator equal</a> element inside. <code>Elem</code> will be inserted before the element pointed by <code>list</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list (also specifying the place where to insert the new element).
<dd><code>elem</code> - the element to add.
'
echo "${sglib_dl_list_comparator_next_parameters}"
echo "${sglib_dl_list_add_member_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_ADD_AFTER_IF_NOT_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_ADD_AFTER_IF_NOT_MEMBER(type, list, elem, comparator, previous, next, member)</b></code>
<br>
<br>
add an element to a list if there is no <a href="#comparator_equality">comparator equal</a> element inside. <code>Elem</code> will be inserted after the element pointed by <code>list</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list (also specifying the place where to insert the new element).
<dd><code>elem</code> - the element to add.
'
echo "${sglib_dl_list_comparator_next_parameters}"
echo "${sglib_dl_list_add_member_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_CONCAT</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_CONCAT(type, first, second, previous, next)</b></code>
<br>
<br>
concatenate two lists by appending the second at the end of the first.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>first</code> - the first list.
<dd><code>second</code> - the second list.
'
echo "${sglib_dl_list_previous_next_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_DELETE</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_DELETE(type, list, elem, previous, next)</b></code>
<br>
<br>
delete an element from a list. The element must be a <a href="#pointer_member">pointer equal member</a> of the list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to delete.
'
echo "${sglib_dl_list_previous_next_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_DELETE_IF_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_DELETE_IF_MEMBER(type, list, elem, comparator, previous, next, member)</b></code>
<br>
<br>
remove a <a href="#comparator_equality">comparator equal</a> element from a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_dl_list_delete_member_parameter='
<dd><code>member</code> - (output) NULL, if the <code>elem</code> was not inside the <code>list</code>, otherwise this variable is set to the deleted element.
'
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to delete.
'
echo "${sglib_dl_list_comparator_next_parameters}"
echo "${sglib_dl_list_delete_member_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_IS_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_IS_MEMBER(type, list, elem, previous, next, result)</b></code>
<br>
<br>
determine whether an element is a <a href="#pointer_member">pointer member</a> of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to search.
'
echo "${sglib_dl_list_previous_next_parameter}"
echo '
<dd><code>result</code> - (output) set to zero, if <code>elem</code> is not memebr of the <code>list</code>, non-zero otherwise.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_FIND_MEMBER</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_FIND_MEMBER(type, list, elem, comparator, previous, next, result)</b></code>
<br>
<br>
determine whether there is a <a href="#comparator_equality">comparator equal</a> element in a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>elem</code> - the element to search.
'
echo "${sglib_dl_list_comparator_next_parameters}"
echo '
<dd><code>result</code> - (output) set to the resulting member. This variable is NULL if the <code>elem</code> has not been found in the <code>list</code>.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_GET_FIRST</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_GET_FIRST(type, list, previous, next, result)</b></code>
<br>
<br>
get the first element of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
'
echo "${sglib_dl_list_previous_next_parameter}"
echo '
<dd><code>result</code> - (output) the first element of the <code>list</code>.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_GET_LAST</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_GET_LAST(type, list, previous, next, result)</b></code>
<br>
<br>
get the last element of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
'
echo "${sglib_dl_list_previous_next_parameter}"
echo '
<dd><code>result</code> - (output) the last element of the <code>list</code>.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_LEN</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_LEN(type, list, previous, next, result)</b></code>
<br>
<br>
compute the length of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
'
echo "${sglib_dl_list_previous_next_parameter}"
echo '
<dd><code>result</code> - (output) the length of the <code>list</code>.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_MAP_ON_ELEMENTS</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_MAP_ON_ELEMENTS(type, list, var, previous, next, command)</b></code>
<br>
<br>
apply a command on all elements of a list. <code>Command</code> will be repeatedly executed for each element of the list accessible via the <code>previous</code> field and then via the <code>next</code> field. The current element of the list is stored in the
variable <code>var</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list.
<dd><code>var</code> - the variable which will run through each element of the list.
'
echo "${sglib_dl_list_previous_next_parameter}"
echo '
<dd><code>command</code> - any (possibly composed) statement of the C language. In the statement you can use the variable <code>var</code> (third parameter of the macro) going through all 
elements of the list.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_REVERSE</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_REVERSE(type, list, previous, next)</b></code>
<br>
<br>
reverse a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list to reverse.
'
echo "${sglib_dl_list_previous_next_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DL_LIST_SORT</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DL_LIST_SORT(type, list, comparator, previous, next)</b></code>
<br>
<br>
sort a list using mergesort. As a side effect the <code>list</code> is set to the first element of the list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_type_parameter}"
echo '
<dd><code>list</code> - the list to sort
'
echo "${sglib_dl_list_comparator_next_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>


</table>


#SPARSE_SHELL_SCRIPT_EXECUTE
######################################################################################################################
################################             BIN TREE API LEVEL 0           ######################################
######################################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END

<br><br>

<a name="bin_tree_api0"></a>

<h2>Binary Trees API: level 0</h2>

<table border=1 CELLPADDING="10" CELLSPACING="0">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_BIN_TREE_MAP_ON_ELEMENTS</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_BIN_TREE_MAP_ON_ELEMENTS(type, tree, var, left, right, command)</b></code>
<br>
<br>
traverse a binary tree and apply command on each element. This is non-recursive implementation of tree traversal. It maintains the path to the current node in the array <code>_path_</code>, the <code>_path_[0]</code> contains the root of the tree. The <code>_path_[_pathi_-1]</code> contains the parent of the <code>var</code>. The maximal deep of the tree is limited by <code>SGLIB_MAX_TREE_DEEP</code> macro.

<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_tree_left_right_parameters='
<dd><code>left</code> - the name of the field pointing to the <a href="#left_right_element">left</a> subtree of the tree.
<dd><code>right</code> - the name of the field pointing to the <a href="#left_right_element">right</a> subtree of the tree.
'
echo '
<dd><code>type</code> - the type of the tree data structure.
'
echo '
<dd><code>tree</code> - the tree.
<dd><code>var</code> - the variable which will run through each element of the tree.
'
echo "${sglib_tree_left_right_parameters}"
echo '
<dd><code>command</code> - any (possibly composed) statement of the C language. In the statement you can use the variable <code>var</code> (third parameter of the macro) going through all 
elements of the tree.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

</table>



#SPARSE_SHELL_SCRIPT_EXECUTE
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
################################                  API LEVEL 1            ##################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END

<br><br>
<br><br>
<br><br>

<a name="api1"></a>


<h2>API: level 1</h2>

The level - 1 application interface consists of two stages. First you need to
invoke a generic macro for given data type and then you can use a collection
of functions generated by the macro (see also our <a href="#examples">samples</a>
for the difference between the two interfaces). 
Function names
are composed from the name of the base type given by the user.








#SPARSE_SHELL_SCRIPT_EXECUTE
######################################################################################################################
################################                  ARRAYS API LEVEL 1            ######################################
######################################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END



<br><br><br><br><br><br>
<br><br><br><br><br><br>


<a name="array_api1"></a>


<h2>Arrays API: level 1</h2>

<table border=3 CELLPADDING="10" CELLSPACING="0">

<tr><td width=90%>

<table border=1 CELLPADDING="10" CELLSPACING="0">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_ARRAY_SORTING_PROTOTYPES</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DEFINE_ARRAY_SORTING_PROTOTYPES(type, comparator)</b></code>
<br>
<br>
define headers of array sorting functions. 
Declared functions are:
<br>
<a href="#sglib_type_array_quick_sort">sglib_<font  face="Arial" color="909090">type</font>_array_quick_sort</a> 
<br>
<a href="#sglib_type_array_heap_sort">sglib_<font  face="Arial" color="909090">type</font>_array_heap_sort</a>
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_define_array_sorting_functions_parameters='
<dd><code>type</code> - the type of array elements. It <b>must</b> be a single identifier.
<dd><code>comparator</code> - a <a href="#comparator">comparator</a> used to compare elements.
'
echo "${sglib_define_array_sorting_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_ARRAY_SORTING_FUNCTIONS</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="SGLIB_DEFINE_ARRAY_SORTING_FUNCTIONS"></a>
<code><b>SGLIB_DEFINE_ARRAY_SORTING_FUNCTIONS(type, comparator)</b></code>
<br>
<br>
define the array sorting functions.
Defined functions are:
<br>
<a href="#sglib_type_array_quick_sort">sglib_<font  face="Arial" color="909090">type</font>_array_quick_sort</a> 
<br>
<a href="#sglib_type_array_heap_sort">sglib_<font  face="Arial" color="909090">type</font>_array_heap_sort</a>
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_array_sorting_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

</table>

<br>
<h4>Functions generated by above macros:</b4>
<br>
<br>

<table border=1 CELLPADDING="10" CELLSPACING="1">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_array_quick_sort</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_type_array_quick_sort"></a>
<code><b>sglib_<font  face="Arial" color="909090">type</font>_array_quick_sort(<font  face="Arial" color="909090">type</font> *a, int max)</b></code>
<br>
<br>
sort an array using quicksort.
<dd><dl>
<dt><b>Parameters:</b>
<dd><code>a</code> - the array to sort.
<dd><code>max</code> - the number of elements in the array.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_ARRAY_SORTING_FUNCTIONS"><b>SGLIB_DEFINE_ARRAY_SORTING_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_array_sorting_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_array_heap_sort</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_type_array_heap_sort"></a>
<code><b>sglib_<font  face="Arial" color="909090">type</font>_array_heap_sort(<font  face="Arial" color="909090">type</font> *a, int max)</b></code>
<br>
<br>
sort an array using heapsort.
<dd><dl>
<dt><b>Parameters:</b>
<dd><code>a</code> - the array to sort.
<dd><code>max</code> - the number of elements in the array.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_ARRAY_SORTING_FUNCTIONS"><b>SGLIB_DEFINE_ARRAY_SORTING_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_array_sorting_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>

</table>

</td></tr>
</table>











#SPARSE_SHELL_SCRIPT_EXECUTE
######################################################################################################################
################################             HASHED CONTAINER API LEVEL 1            #################################
######################################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END



<br><br><br><br><br><br>
<br><br><br><br><br><br>

<a name="hashed_container_api1"></a>


<h2>Hashed Containers API: level 1</h2>


Usually, in libraries similar to sglib, a hashed container is an array
where each cell contains a (possibly empty) list of elements.


In sglib we use a more abstract notion of hashed container.  A hashed
container is a table of fixed size containing another (we say
<em>base</em>) container in each cell. Once an object is going to be
inserted into the hashed container, the hash function is used to
determine the cell where it belongs and then the object is inserted
into the base container stored in this cell. The base container is
usualy a list, however it can be a sorted list, double linked list or
a red-black tree as well. Sglib's hashed container is parametrized by
the name of the base container.

<p>
Hashed containers are provided only in level-1 interface because they
require a uniform interface for operations applied on the base container.

<br> <br> <br>

<table border=3 CELLPADDING="10" CELLSPACING="0">

<tr><td width=90%>

<table border=1 CELLPADDING="10" CELLSPACING="0">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_HASHED_CONTAINER_PROTOTYPES</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DEFINE_HASHED_CONTAINER_PROTOTYPES(type, dim, hash_function)</b></code>
<br>
<br>
define headers of hashed container functions and iterator.
It defines structure <em>sglib_hashed_<font  face="Arial" color="909090">type</font>_iterator</em>
and declares functions:
<br>
<a href="#sglib_hashed_type_init">sglib_hashed_<font  face="Arial" color="909090">type</font>_init</a> 
<br>
<a href="#sglib_hashed_type_add">sglib_hashed_<font  face="Arial" color="909090">type</font>_add</a> 
<br>
<a href="#sglib_hashed_type_add_if_not_member">sglib_hashed_<font  face="Arial" color="909090">type</font>_add_if_not_member</a> 
<br>
<a href="#sglib_hashed_type_delete">sglib_hashed_<font  face="Arial" color="909090">type</font>_delete</a> 
<br>
<a href="#sglib_hashed_type_delete_if_member">sglib_hashed_<font  face="Arial" color="909090">type</font>_delete_if_member</a> 
<br>
<a href="#sglib_hashed_type_is_member">sglib_hashed_<font  face="Arial" color="909090">type</font>_is_member</a> 
<br>
<a href="#sglib_hashed_type_find_member">sglib_hashed_<font  face="Arial" color="909090">type</font>_find_member</a> 
<br>
<a href="#sglib_hashed_type_it_init">sglib_hashed_<font  face="Arial" color="909090">type</font>_it_init</a> 
<br>
<a href="#sglib_hashed_type_it_init_on_equal">sglib_hashed_<font  face="Arial" color="909090">type</font>_it_init_on_equal</a> 
<br>
<a href="#sglib_hashed_type_it_next">sglib_hashed_<font  face="Arial" color="909090">type</font>_it_next</a> 
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_define_hashed_container_functions_parameters='
<dd><code>type</code> - the type of the base container. It <b>must</b> be a single identifier.
<dd><code>dim</code> - the size of the array.
<dd><code>hash_function</code> - the hashing function mapping elements into unsigned integers.
'
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS"></a>
<code><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS(type, dim, hash_function)</b></code>
<br>
<br>
define the hashed container functions.
Defined functions are:
<br>
<a href="#sglib_hashed_type_init">sglib_hashed_<font  face="Arial" color="909090">type</font>_init</a> 
<br>
<a href="#sglib_hashed_type_add">sglib_hashed_<font  face="Arial" color="909090">type</font>_add</a> 
<br>
<a href="#sglib_hashed_type_add_if_not_member">sglib_hashed_<font  face="Arial" color="909090">type</font>_add_if_not_member</a> 
<br>
<a href="#sglib_hashed_type_delete">sglib_hashed_<font  face="Arial" color="909090">type</font>_delete</a> 
<br>
<a href="#sglib_hashed_type_delete_if_member">sglib_hashed_<font  face="Arial" color="909090">type</font>_delete_if_member</a> 
<br>
<a href="#sglib_hashed_type_"is_member>sglib_hashed_<font  face="Arial" color="909090">type</font>_is_member</a> 
<br>
<a href="#sglib_hashed_type_find_member">sglib_hashed_<font  face="Arial" color="909090">type</font>_find_member</a> 
<br>
<a href="#sglib_hashed_type_it_init">sglib_hashed_<font  face="Arial" color="909090">type</font>_it_init</a> 
<br>
<a href="#sglib_hashed_type_it_init_on_equal">sglib_hashed_<font  face="Arial" color="909090">type</font>_it_init_on_equal</a> 
<br>
<a href="#sglib_hashed_type_it_next">sglib_hashed_<font  face="Arial" color="909090">type</font>_it_next</a> 
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

</table>

<br>
<h4>Functions generated by above macros:</b4>
<br>
<br>

<table border=1 CELLPADDING="10" CELLSPACING="1">


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_hashed_<font face="Arial" color="909090">type</font>_init</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_hashed_type_init"></a>
<code><b>void sglib_hashed_<font  face="Arial" color="909090">type</font>_init(<font  face="Arial" color="909090">type</font> *table[<font  face="Arial" color="909090">dim</font>])</b></code>
<br>
<br>
set each cell in the table to NULL.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_hashed_container_table_parameter='
<dd><code>table</code> - the hashed container.
'
echo "${sglib_hashed_container_table_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS"><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>



<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_hashed_<font face="Arial" color="909090">type</font>_add</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_hashed_type_add"></a>
<code><b>void sglib_hashed_<font  face="Arial" color="909090">type</font>_add(<font  face="Arial" color="909090">type</font> *table[<font  face="Arial" color="909090">dim</font>], <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
Add an element into the hashed container.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_hashed_container_table_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><code>elem</code> - the element to be added.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS"><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>





<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_hashed_<font face="Arial" color="909090">type</font>_add_if_not_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_hashed_type_add_if_not_member"></a>
<code><b>int sglib_hashed_<font  face="Arial" color="909090">type</font>_add_if_not_member(<font  face="Arial" color="909090">type</font> *table[<font  face="Arial" color="909090">dim</font>], <font  face="Arial" color="909090">type</font> *elem, <font  face="Arial" color="909090">type</font> **member)</b></code>
<br>
<br>
Add an element into the hashed container if there is no <a href="#comparator_equality">comparator equal</a> element inside.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_hashed_container_table_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><code>elem</code> - the element to be added.
<dd><code>member</code> - in case if the element is a member of the container, set <code>*member</code> to it.
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was inserted to the container. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS"><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>





<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_hashed_<font face="Arial" color="909090">type</font>_delete</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_hashed_type_delete"></a>
<code><b>void sglib_hashed_<font  face="Arial" color="909090">type</font>_delete(<font  face="Arial" color="909090">type</font> *table[<font  face="Arial" color="909090">dim</font>], <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
delete an element from a hashed container. The element must be a <a href="#pointer_equality">pointer equal</a> member of the hashed container.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_hashed_container_table_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><code>elem</code> - the element to be removed.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS"><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>







<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_hashed_<font face="Arial" color="909090">type</font>_delete_if_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_hashed_type_delete_if_member"></a>
<code><b>int sglib_hashed_<font  face="Arial" color="909090">type</font>_delete_if_member(<font  face="Arial" color="909090">type</font> *table[<font  face="Arial" color="909090">dim</font>], <font  face="Arial" color="909090">type</font> *elem, <font  face="Arial" color="909090">type</font> **member)</b></code>
<br>
<br>
find a <a href="#comparator_equality">comparator equal</a> element in the hashed container and remove it.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_hashed_container_table_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><code>elem</code> - the element to be removed.
<dd><code>member</code> - in case if the element is a member of the list, set <code>*member</code> to the removed element.
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was removed from the container. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS"><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>







<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_hashed_<font face="Arial" color="909090">type</font>_is_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_hashed_type_is_member"></a>
<code><b>int sglib_hashed_<font  face="Arial" color="909090">type</font>_is_member(<font  face="Arial" color="909090">type</font> *table[<font  face="Arial" color="909090">dim</font>], <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
determine whether an element is inside a hashed container. The element is searched using <a href="#comparator_equality">pointer equality</a>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_hashed_container_table_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><code>elem</code> - the element to be searched.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS"><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>







<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_hashed_<font face="Arial" color="909090">type</font>_find_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_hashed_type_find_member"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_hashed_<font  face="Arial" color="909090">type</font>_find_member(<font  face="Arial" color="909090">type</font> *table[<font  face="Arial" color="909090">dim</font>], <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
find an element in the hashed container. The element is searched using <a href="#comparator_equality">comparator equality</a>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_hashed_container_table_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><code>elem</code> - the element to be searched.
</dt>
<dt><b>Returns:</b>
<dd>The member of the container <a href="#comparator_equality">comparator equal</a> to <code>elem</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS"><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>









<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_hashed_<font face="Arial" color="909090">type</font>_it_init</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_hashed_type_it_init"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_hashed_<font  face="Arial" color="909090">type</font>_it_init(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it, <font  face="Arial" color="909090">type</font> *table[<font  face="Arial" color="909090">dim</font>])</b></code>
<br>
<br>
initialize an iterator <code>it</code> to run over elements of <code>table</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_hashed_container_iterator_parameter='
<dd><code>it</code> - the iterator.
'
echo "${sglib_hashed_container_iterator_parameter}"
echo "${sglib_hashed_container_table_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The first iterated element or <code>NULL</code> if there is no element.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS"><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>






<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_hashed_<font face="Arial" color="909090">type</font>_it_init_on_equal</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_hashed_type_it_init_on_equal"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_hashed_<font  face="Arial" color="909090">type</font>_it_init_on_equal(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it, <font  face="Arial" color="909090">type</font> *table[<font  face="Arial" color="909090">dim</font>], int (*subcomparator)(<font  face="Arial" color="909090">type</font> *, <font  face="Arial" color="909090">type</font> *), <font  face="Arial" color="909090">type</font> *equalto)</b></code>
<br>
<br>
initialize an iterator <code>it</code> to run over those elements of <code>table</code> which are
equal to <code>equalto</code>. The equality is considered with respect to the 
<code>subcomparator</code> which must be a <a href="#subcomparator">subcomparator</a> 
of the base container comparator.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_hashed_container_iterator_parameter}"
echo "${sglib_hashed_container_table_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><code>subcomparator</code> - the comparator used to find equal elements.
<dd><code>equalto</code> - the element used as filter.
</dt>
<dt><b>Returns:</b>
<dd>The first iterated element or <code>NULL</code> if there is no element equal to <code>equalto</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS"><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>








<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_hashed_<font face="Arial" color="909090">type</font>_it_next</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_hashed_type_it_next"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_hashed_<font  face="Arial" color="909090">type</font>_it_next(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it)</b></code>
<br>
<br>
get the next element from the iterator <code>it</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_hashed_container_iterator_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The next iterated element or <code>NULL</code> if there is no next element.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS"><b>SGLIB_DEFINE_HASHED_CONTAINER_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_hashed_container_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


</table>

</td></tr>
</table>









#SPARSE_SHELL_SCRIPT_EXECUTE
###############################################################################################################
################################             LISTS API LEVEL 1           ######################################
###############################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END


<br><br><br><br><br><br>
<br><br><br><br><br><br>

<a name="list_api1"></a>

<h2>Linked lists API: level 1</h2>


<table border=3 CELLPADDING="10" CELLSPACING="0">

<tr><td width=90%>

<table border=1 CELLPADDING="10" CELLSPACING="0">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_LIST_PROTOTYPES</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DEFINE_LIST_PROTOTYPES(type, comparator, next)</b></code>
<br>
<br>
define headers for linked list functions. 
Declared functions are:
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_define_list_prototype_functions='
<br><a href="#sglib_list_type_add">sglib_<font  face="Arial" color="909090">type</font>_add</a>
<br><a href="#sglib_list_type_add_if_not_member">sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member</a>
<br><a href="#sglib_list_type_concat">sglib_<font  face="Arial" color="909090">type</font>_concat</a>
<br><a href="#sglib_list_type_delete">sglib_<font  face="Arial" color="909090">type</font>_delete</a>
<br><a href="#sglib_list_type_delete_if_member">sglib_<font  face="Arial" color="909090">type</font>_delete_if_member</a>
<br><a href="#sglib_list_type_find_member">sglib_<font  face="Arial" color="909090">type</font>_find_member</a>
<br><a href="#sglib_list_type_is_member">sglib_<font  face="Arial" color="909090">type</font>_is_member</a>
<br><a href="#sglib_list_type_len">sglib_<font  face="Arial" color="909090">type</font>_len</a>
<br><a href="#sglib_list_type_sort">sglib_<font  face="Arial" color="909090">type</font>_sort</a>
<br><a href="#sglib_list_type_reverse">sglib_<font  face="Arial" color="909090">type</font>_reverse</a>
<br><a href="#sglib_list_type_it_init">sglib_<font  face="Arial" color="909090">type</font>_it_init</a> 
<br><a href="#sglib_list_type_it_init_on_equal">sglib_<font  face="Arial" color="909090">type</font>_it_init_on_equal</a> 
<br><a href="#sglib_list_type_it_next">sglib_<font  face="Arial" color="909090">type</font>_it_next</a> 
'
echo "${sglib_define_list_prototype_functions}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<br>
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_define_list_functions_parameters="${sglib_list_type_parameter}${sglib_list_comparator_next_parameters}"
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="SGLIB_DEFINE_LIST_FUNCTIONS"></a>
<code><b>SGLIB_DEFINE_LIST_FUNCTIONS(type, comparator, next)</b></code>
<br>
<br>
define functions for manipulating linked lists. 
Defined functions are:
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_prototype_functions}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

</table>

<br>
<h4>Functions generated by above macros:</b4>
<br>
<br>

<table border=1 CELLPADDING="10" CELLSPACING="1">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_add"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_add(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
insert an element into a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_list_functions_list_parameter='
<dd><code>list</code> - the list.
'
echo "${sglib_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to insert.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_add_if_not_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem, <font  face="Arial" color="909090">type</font> **member)</b></code>
<br>
<br>
insert an element if there is no <a href="#comparator_equality">comparator equal</a> element in the list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to insert.
<dd><code>member</code> - in case if the element is a member of the list, set <code>*member</code> to it.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was inserted to the list. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_concat</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_concat"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_concat(<font  face="Arial" color="909090">type</font> **first, <font  face="Arial" color="909090">type</font> *second)</b></code>
<br>
<br>
concatenate two lists by appending second at the end of the first.
<dd><dl>
<dt><b>Parameters:</b>
<dd><code>first</code> - the first list, it will contain the result of the concatenation.
<dd><code>second</code> - the second list.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_delete</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_delete"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_delete(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
delete an element. The element must be a member of the <em>list</em>, it is looked using the <a href="#pointer_equality">pointer equality</a>, not equality generated by <font  face="Arial" color="909090">comparator</font>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to delete.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_delete_if_member</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_delete_if_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_delete_if_member(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem, <font  face="Arial" color="909090">type</font> **result)</b></code>
<br>
<br>
find a <a href="#comparator_equality">comparator equal</a> element in the list and remove it.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to search.
<dd><code>result</code> - an output variable pointer. The variable will be set to the element removed from the list.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was removed from the list. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_is_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_is_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_is_member(<font  face="Arial" color="909090">type</font> *list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
determine whether an element is inside a list. The element is searched using <a href="#comparator_equality">pointer equality</a>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to search.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element is in the list. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_find_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_find_member"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_find_member(<font  face="Arial" color="909090">type</font> *list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
find an element in the list. The element is searched using <a href="#comparator_equality">comparator equality</a>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to search.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The member of the list <a href="#comparator_equality">comparator equal</a> to <code>elem</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_len</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_len"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_len(<font  face="Arial" color="909090">type</font> *list)</b></code>
<br>
<br>
compute the length of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The lenght of the <code>list</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>




<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_sort</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_sort"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_sort(<font  face="Arial" color="909090">type</font> **list)</b></code>
<br>
<br>
sort the list according to <font  face="Arial" color="909090">comparator</font>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>




<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_reverse</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_reverse"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_reverse(<font  face="Arial" color="909090">type</font> **list)</b></code>
<br>
<br>
reverse the list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>








#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
#some definitions common for list iterators
sglib_list_iterator_parameter='
<dd><code>it</code> - the iterator.
'
sglib_list_iterator_init_description='
initialize an iterator <code>it</code> to run over elements of <code>list</code>.
'
sglib_list_iterator_init_result_description='
<dd>The first iterated element or <code>NULL</code> if there is no element.
'
sglib_list_iterator_init_eq_description='
initialize an iterator <code>it</code> to run over those elements of <code>list</code> which are
equal to <code>equalto</code>. The equality is considered with respect to the 
<code>subcomparator</code> which must be a <a href="#subcomparator">subcomparator</a> 
of the <font  face="Arial" size=-1 color="909090">comparator</font>.
'
sglib_list_iterator_init_eq_pars_description='
<dd><code>subcomparator</code> - the comparator used to find equal elements.
<dd><code>equalto</code> - the element used as filter.
'
sglib_list_iterator_init_eq_result_description='
<dd>The first iterated element or <code>NULL</code> if there is no element equal to <code>equalto</code>.
'
sglib_list_iterator_next_description='
get the next element from the iterator <code>it</code>.
'
sglib_list_iterator_next_result_description='
<dd>The next iterated element or <code>NULL</code> if there is no next element.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END






<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_init</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_it_init"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_init(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it, <font  face="Arial" color="909090">type</font> *list)</b></code>
<br>
<br>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_init_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_parameter}"
echo "${sglib_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "$sglib_list_iterator_init_result_description"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>









<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_init_on_equal</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_it_init_on_equal"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_init_on_equal(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it, <font  face="Arial" color="909090">type</font> *list, int (*subcomparator)(<font  face="Arial" color="909090">type</font> *, <font  face="Arial" color="909090">type</font> *), <font  face="Arial" color="909090">type</font> *equalto)</b></code>
<br>
<br>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_init_eq_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_parameter}"
echo "${sglib_list_functions_list_parameter}"
echo "${sglib_list_iterator_init_eq_pars_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_init_eq_result_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>










<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_next</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_list_type_it_next"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_next(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it)</b></code>
<br>
<br>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_next_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_next_result_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_LIST_FUNCTIONS"><b>SGLIB_DEFINE_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>



</table>

</td></tr>
</table>



<br><br>
<br><br>



















#SPARSE_SHELL_SCRIPT_EXECUTE
###############################################################################################################
############################             SORTED LISTS API LEVEL 1           ###################################
###############################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END

<a name="sorted_list_api1"></a>

<h2>Sorted Linked lists API: level 1</h2>


<table border=3 CELLPADDING="10" CELLSPACING="0">

<tr><td width=90%>

<table border=1 CELLPADDING="10" CELLSPACING="0">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_SORTED_LIST_PROTOTYPES</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DEFINE_SORTED_LIST_PROTOTYPES(type, comparator, next)</b></code>
<br>
<br>
define headers for sorted linked list functions. 
Declared functions are:
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_define_sorted_list_prototype_functions='
<br><a href="#sglib_sorted_list_type_add">sglib_<font  face="Arial" color="909090">type</font>_add</a>
<br><a href="#sglib_sorted_list_type_add_if_not_member">sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member</a>
<br><a href="#sglib_sorted_list_type_delete">sglib_<font  face="Arial" color="909090">type</font>_delete</a>
<br><a href="#sglib_sorted_list_type_delete_if_member">sglib_<font  face="Arial" color="909090">type</font>_delete_if_member</a>
<br><a href="#sglib_sorted_list_type_find_member">sglib_<font  face="Arial" color="909090">type</font>_find_member</a>
<br><a href="#sglib_sorted_list_type_is_member">sglib_<font  face="Arial" color="909090">type</font>_is_member</a>
<br><a href="#sglib_sorted_list_type_len">sglib_<font  face="Arial" color="909090">type</font>_len</a>
<br><a href="#sglib_sorted_list_type_sort">sglib_<font  face="Arial" color="909090">type</font>_sort</a>
<br><a href="#sglib_sorted_list_type_it_init">sglib_<font  face="Arial" color="909090">type</font>_it_init</a> 
<br><a href="#sglib_sorted_list_type_it_init_on_equal">sglib_<font  face="Arial" color="909090">type</font>_it_init_on_equal</a> 
<br><a href="#sglib_sorted_list_type_it_next">sglib_<font  face="Arial" color="909090">type</font>_it_next</a> 
'
echo "${sglib_define_sorted_list_prototype_functions}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<br>
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_define_sorted_list_functions_parameters="${sglib_list_type_parameter}${sglib_list_comparator_next_parameters}"
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"></a>
<code><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS(type, comparator, next)</b></code>
<br>
<br>
define functions for manipulating sorted linked lists. 
Defined functions are:
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_prototype_functions}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

</table>

<br>
<h4>Functions generated by above macros:</b4>
<br>
<br>

<table border=1 CELLPADDING="10" CELLSPACING="1">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_sorted_list_type_add"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_add(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
insert an element into a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_sorted_list_functions_list_parameter='
<dd><code>list</code> - the list.
'
echo "${sglib_sorted_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to insert.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_sorted_list_type_add_if_not_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem, <font  face="Arial" color="909090">type</font> **member)</b></code>
<br>
<br>
insert an element if there is no <a href="#comparator_equality">comparator equal</a> element in the list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_sorted_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to insert.
<dd><code>member</code> - in case if the element is a member of the list, set <code>*member</code> to it.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was inserted to the list. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_delete</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_sorted_list_type_delete"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_delete(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
delete an element. The element must be a member of the <em>list</em>, it is looked using the <a href="#pointer_equality">pointer equality</a>, not equality generated by <font  face="Arial" color="909090">comparator</font>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_sorted_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to delete.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_delete_if_member</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_sorted_list_type_delete_if_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_delete_if_member(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem, <font  face="Arial" color="909090">type</font> **result)</b></code>
<br>
<br>
find a <a href="#comparator_equality">comparator equal</a> element in the list and remove it.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_sorted_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to search.
<dd><code>result</code> - an output variable pointer. The variable will be set to the element removed from the list.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was removed from the list. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_is_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_sorted_list_type_is_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_is_member(<font  face="Arial" color="909090">type</font> *list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
determine whether an element is inside a list. The element is searched using <a href="#comparator_equality">pointer equality</a>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_sorted_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to search.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element is in the list. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_find_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_sorted_list_type_find_member"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_find_member(<font  face="Arial" color="909090">type</font> *list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
find an element in the list. The element is searched using <a href="#comparator_equality">comparator equality</a>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_sorted_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to search.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The member of the list <a href="#comparator_equality">comparator equal</a> to <code>elem</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_len</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_sorted_list_type_len"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_len(<font  face="Arial" color="909090">type</font> *list)</b></code>
<br>
<br>
compute the length of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_sorted_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The lenght of the <code>list</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>



<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_sort</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_sorted_list_type_sort"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_sort(<font  face="Arial" color="909090">type</font> **list)</b></code>
<br>
<br>
sort the list according to <font  face="Arial" color="909090">comparator</font>. This function does not logically
belong to this datatype as it is supposed that lists are kept sorted. However, it can be used
to initial sorting, when the <code>list</code> was created by other than sglib functions.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_sorted_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>








<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_init</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_sorted_list_type_it_init"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_init(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it, <font  face="Arial" color="909090">type</font> *list)</b></code>
<br>
<br>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_init_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_parameter}"
echo "${sglib_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "$sglib_list_iterator_init_result_description"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>









<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_init_on_equal</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_sorted_list_type_it_init_on_equal"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_init_on_equal(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it, <font  face="Arial" color="909090">type</font> *list, int (*subcomparator)(<font  face="Arial" color="909090">type</font> *, <font  face="Arial" color="909090">type</font> *), <font  face="Arial" color="909090">type</font> *equalto)</b></code>
<br>
<br>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_init_eq_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_parameter}"
echo "${sglib_list_functions_list_parameter}"
echo "${sglib_list_iterator_init_eq_pars_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_init_eq_result_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>










<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_next</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_sorted_list_type_it_next"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_next(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it)</b></code>
<br>
<br>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_next_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_next_result_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_SORTED_LIST_FUNCTIONS"><b>SGLIB_DEFINE_SORTED_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_sorted_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>




</table>

</td></tr>
</table>



<br><br>
<br><br>














#SPARSE_SHELL_SCRIPT_EXECUTE
###############################################################################################################
################################     DOUBLE LINKED LISTS API LEVEL 1           ################################
###############################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END


<a name="dl_list_api1"></a>

<h2>Double linked lists API: level 1</h2>


<table border=3 CELLPADDING="10" CELLSPACING="0">

<tr><td width=90%>

<table border=1 CELLPADDING="10" CELLSPACING="0">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_DL_LIST_PROTOTYPES</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DEFINE_DL_LIST_PROTOTYPES(type, comparator, previous, next)</b></code>
<br>
<br>
define headers for double linked list functions. 
Declared functions are:
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_define_dl_list_prototype_functions='
<br><a href="#sglib_dl_list_type_add">sglib_<font  face="Arial" color="909090">type</font>_add</a>
<br><a href="#sglib_dl_list_type_add_before">sglib_<font  face="Arial" color="909090">type</font>_add_before</a>
<br><a href="#sglib_dl_list_type_add_after">sglib_<font  face="Arial" color="909090">type</font>_add_after</a>
<br><a href="#sglib_dl_list_type_add_if_not_member">sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member</a>
<br><a href="#sglib_dl_list_type_add_before_if_not_member">sglib_<font  face="Arial" color="909090">type</font>_add_before_if_not_member</a>
<br><a href="#sglib_dl_list_type_add_after_if_not_member">sglib_<font  face="Arial" color="909090">type</font>_add_after_if_not_member</a>
<br><a href="#sglib_dl_list_type_concat">sglib_<font  face="Arial" color="909090">type</font>_concat</a>
<br><a href="#sglib_dl_list_type_delete">sglib_<font  face="Arial" color="909090">type</font>_delete</a>
<br><a href="#sglib_dl_list_type_delete_if_member">sglib_<font  face="Arial" color="909090">type</font>_delete_if_member</a>
<br><a href="#sglib_dl_list_type_find_member">sglib_<font  face="Arial" color="909090">type</font>_find_member</a>
<br><a href="#sglib_dl_list_type_is_member">sglib_<font  face="Arial" color="909090">type</font>_is_member</a>
<br><a href="#sglib_dl_list_type_get_first">sglib_<font  face="Arial" color="909090">type</font>_get_first</a>
<br><a href="#sglib_dl_list_type_get_last">sglib_<font  face="Arial" color="909090">type</font>_get_last</a>
<br><a href="#sglib_dl_list_type_len">sglib_<font  face="Arial" color="909090">type</font>_len</a>
<br><a href="#sglib_dl_list_type_sort">sglib_<font  face="Arial" color="909090">type</font>_sort</a>
<br><a href="#sglib_dl_list_type_reverse">sglib_<font  face="Arial" color="909090">type</font>_reverse</a>
<br><a href="#sglib_dl_list_type_it_init">sglib_<font  face="Arial" color="909090">type</font>_it_init</a> 
<br><a href="#sglib_dl_list_type_it_init_on_equal">sglib_<font  face="Arial" color="909090">type</font>_it_init_on_equal</a> 
<br><a href="#sglib_dl_list_type_it_next">sglib_<font  face="Arial" color="909090">type</font>_it_next</a> 
'
echo "${sglib_define_dl_list_prototype_functions}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<br>
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_define_dl_list_functions_parameters="${sglib_dl_list_type_parameter}${sglib_dl_list_comparator_next_parameters}"
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="SGLIB_DEFINE_DL_LIST_FUNCTIONS"></a>
<code><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS(type, comparator, previous, next)</b></code>
<br>
<br>
define functions for manipulating linked lists. 
Defined functions are:
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_prototype_functions}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

</table>

<br>
<h4>Functions generated by above macros:</b4>
<br>
<br>

<table border=1 CELLPADDING="10" CELLSPACING="1">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_add"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_add(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
insert an element into a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_dl_list_functions_list_parameter='
<dd><code>list</code> - the list.
'
echo "${sglib_dl_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to insert.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add_before</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_add_before"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_add_before(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
insert an element into a list. <code>Elem</code> will be inserted before the element pointed by <code>*list</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_dl_list_addbf_functions_paramets='
<dd><code>list</code> - the list (also the place where to insert the new element).
<dd><code>elem</code> - the element to insert.
'
echo "${sglib_dl_list_addbf_functions_paramets}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add_after</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_add_after"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_add_after(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
insert an element into a list. <code>Elem</code> will be inserted after the element pointed by <code>*list</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_addbf_functions_paramets}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_add_if_not_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem, <font  face="Arial" color="909090">type</font> **member)</b></code>
<br>
<br>
insert an element if there is no <a href="#comparator_equality">comparator equal</a> element in the list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to insert.
<dd><code>member</code> - in case if the element is a member of the list, set <code>*member</code> to it.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was inserted to the list. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add_before_if_not_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_add_before_if_not_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_add_before_if_not_member(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
insert an element if there is no <a href="#comparator_equality">comparator equal</a> element in the list.
<code>Elem</code> will be inserted before the element pointed by <code>*list</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_addbf_functions_paramets}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was inserted to the list. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add_after_if_not_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_add_after_if_not_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_add_after_if_not_member(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
insert an element if there is no <a href="#comparator_equality">comparator equal</a> element in the list.
<code>Elem</code> will be inserted before the element pointed by <code>*list</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_addbf_functions_paramets}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was inserted to the list. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_concat</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_concat"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_concat(<font  face="Arial" color="909090">type</font> **first, <font  face="Arial" color="909090">type</font> *second)</b></code>
<br>
<br>
concatenate two lists by appending second at the end of the first.
<dd><dl>
<dt><b>Parameters:</b>
<dd><code>first</code> - the first list, it will contain the result of the concatenation.
<dd><code>second</code> - the second list.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_delete</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_delete"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_delete(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
delete an element. The element must be a <a href="#pointer_equality">pointer equal</a> member of the <em>list</em>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to delete.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_delete_if_member</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_delete_if_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_delete_if_member(<font  face="Arial" color="909090">type</font> **list, <font  face="Arial" color="909090">type</font> *elem, <font  face="Arial" color="909090">type</font> **result)</b></code>
<br>
<br>
find a <a href="#comparator_equality">comparator equal</a> element in the list and remove it.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to search.
<dd><code>result</code> - an output variable pointer. The variable will be set to the element removed from the list.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was removed from the list. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_is_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_is_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_is_member(<font  face="Arial" color="909090">type</font> *list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
determine whether an element is inside a list. The element is searched using <a href="#comparator_equality">pointer equality</a>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to search.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element is in the list. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_find_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_find_member"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_find_member(<font  face="Arial" color="909090">type</font> *list, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
find an element in the list. The element is searched using <a href="#comparator_equality">comparator equality</a>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_functions_list_parameter}"
echo '
<dd><code>elem</code> - the element to search.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The member of the list <a href="#comparator_equality">comparator equal</a> to <code>elem</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_get_first</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_get_first"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_get_first(<font  face="Arial" color="909090">type</font> *list)</b></code>
<br>
<br>
get the first element of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The first element of the <code>list</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>




<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_get_last</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_get_last"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_get_last(<font  face="Arial" color="909090">type</font> *list)</b></code>
<br>
<br>
get the last element of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The last element of the <code>list</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>




<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_len</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_len"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_len(<font  face="Arial" color="909090">type</font> *list)</b></code>
<br>
<br>
compute the length of a list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The lenght of the <code>list</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>




<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_sort</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_sort"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_sort(<font  face="Arial" color="909090">type</font> **list)</b></code>
<br>
<br>
sort the list according to <font  face="Arial" color="909090">comparator</font>. After the sorting <code>*list</code> will point to the first element of the list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>




<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_reverse</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_reverse"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_reverse(<font  face="Arial" color="909090">type</font> **list)</b></code>
<br>
<br>
reverse the list.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_dl_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>










<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_init</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_it_init"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_init(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it, <font  face="Arial" color="909090">type</font> *list)</b></code>
<br>
<br>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_init_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_parameter}"
echo "${sglib_list_functions_list_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "$sglib_list_iterator_init_result_description"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>









<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_init_on_equal</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_it_init_on_equal"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_init_on_equal(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it, <font  face="Arial" color="909090">type</font> *list, int (*subcomparator)(<font  face="Arial" color="909090">type</font> *, <font  face="Arial" color="909090">type</font> *), <font  face="Arial" color="909090">type</font> *equalto)</b></code>
<br>
<br>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_init_eq_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_parameter}"
echo "${sglib_list_functions_list_parameter}"
echo "${sglib_list_iterator_init_eq_pars_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_init_eq_result_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>










<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_next</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_dl_list_type_it_next"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_next(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it)</b></code>
<br>
<br>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_next_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_list_iterator_next_result_description}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_DL_LIST_FUNCTIONS"><b>SGLIB_DEFINE_DL_LIST_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_dl_list_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>




</table>

</td></tr>
</table>



<br><br>
<br><br>






























#SPARSE_SHELL_SCRIPT_EXECUTE
###############################################################################################################
############################           RED-BLACK TREES API LEVEL 1           ##################################
###############################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END

<a name="rbtree_api1"></a>

<h2>Red-Black Trees API: level 1</h2>


<table border=3 CELLPADDING="10" CELLSPACING="0">

<tr><td width=90%>

<table border=1 CELLPADDING="10" CELLSPACING="0">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_RBTREE_PROTOTYPES</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<code><b>SGLIB_DEFINE_RBTREE_PROTOTYPES(type, left, right, colorbit, comparator)</b></code>
<br>
<br>
define headers for red black tree implementation.
Declared functions are:
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_define_rbtree_prototype_functions='
<br><a href="#sglib_rbtree_type_add">sglib_<font  face="Arial" color="909090">type</font>_add</a>
<br><a href="#sglib_rbtree_type_add_if_not_member">sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member</a>
<br><a href="#sglib_rbtree_type_delete">sglib_<font  face="Arial" color="909090">type</font>_delete</a>
<br><a href="#sglib_rbtree_type_delete_if_member">sglib_<font  face="Arial" color="909090">type</font>_delete_if_member</a>
<br><a href="#sglib_rbtree_type_find_member">sglib_<font  face="Arial" color="909090">type</font>_find_member</a>
<br><a href="#sglib_rbtree_type_is_member">sglib_<font  face="Arial" color="909090">type</font>_is_member</a>
<br><a href="#sglib_rbtree_type_len">sglib_<font  face="Arial" color="909090">type</font>_len</a>
<br><a href="#sglib_rbtree_type_it_init">sglib_<font  face="Arial" color="909090">type</font>_it_init</a> 
<br><a href="#sglib_rbtree_type_it_init_on_equal">sglib_<font  face="Arial" color="909090">type</font>_it_init_on_equal</a> 
<br><a href="#sglib_rbtree_type_it_next">sglib_<font  face="Arial" color="909090">type</font>_it_next</a> 
'
echo "${sglib_define_rbtree_prototype_functions}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<br>
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_define_rbtree_functions_parameters='
<dd><code>type</code> - the type of tree elements.
<dd><code>left</code> - the name of  the field containing <a href="#left_right_element">left</a> subtree of a node.
<dd><code>right</code> - the name of  the field containing <a href="#left_right_element">right</a> subtree of a node.
<dd><code>colorbit</code> - the name of the field containing the <a href="#rb_color">color</a> of a node.
<dd><code>comparator</code> - a <a href="#comparator">comparator</a> used to compare elements.
'
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

<tr><td VALIGN="top" WIDTH="1%">
<code><b>SGLIB_DEFINE_RBTREE_FUNCTIONS</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>macro</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="SGLIB_DEFINE_RBTREE_FUNCTIONS"></a>
<code><b>SGLIB_DEFINE_RBTREE_FUNCTIONS(type, left, right, colorbit, comparator)</b></code>
<br>
<br>
define functions for manipulating balanced red-black trees. 
Defined functions are:
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_prototype_functions}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dd>
</td></tr>

</table>

<br>
<h4>Functions generated by above macros:</b4>
<br>
<br>

<table border=1 CELLPADDING="10" CELLSPACING="1">

<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_rbtree_type_add"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_add(<font  face="Arial" color="909090">type</font> **tree, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
insert an element into a tree.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_rbtree_functions_tree_parameter='
<dd><code>tree</code> - the tree.
'
echo "${sglib_rbtree_functions_tree_parameter}"
echo '
<dd><code>elem</code> - the element to insert.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_RBTREE_FUNCTIONS"><b>SGLIB_DEFINE_RBTREE_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_rbtree_type_add_if_not_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_add_if_not_member(<font  face="Arial" color="909090">type</font> **tree, <font  face="Arial" color="909090">type</font> *elem, <font  face="Arial" color="909090">type</font> **member)</b></code>
<br>
<br>
insert an element if there is no <a href="#comparator_equality">comparator equal</a> element in the tree.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_rbtree_functions_tree_parameter}"
echo '
<dd><code>elem</code> - the element to insert.
<dd><code>member</code> - in case if the element is a member of the tree, set <code>*member</code> to it.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was inserted to the tree. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_RBTREE_FUNCTIONS"><b>SGLIB_DEFINE_RBTREE_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_delete</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_rbtree_type_delete"></a>
<code><b>void sglib_<font  face="Arial" color="909090">type</font>_delete(<font  face="Arial" color="909090">type</font> **tree, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
delete an element. The element must be a member of the <em>tree</em>, it is looked using the <a href="#pointer_equality">pointer equality</a>, not equality generated by <font  face="Arial" color="909090">comparator</font>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_rbtree_functions_tree_parameter}"
echo '
<dd><code>elem</code> - the element to delete.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_RBTREE_FUNCTIONS"><b>SGLIB_DEFINE_RBTREE_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_delete_if_member</code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_rbtree_type_delete_if_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_delete_if_member(<font  face="Arial" color="909090">type</font> **tree, <font  face="Arial" color="909090">type</font> *elem, <font  face="Arial" color="909090">type</font> **result)</b></code>
<br>
<br>
find a <a href="#comparator_equality">comparator equal</a> element in the tree and remove it.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_rbtree_functions_tree_parameter}"
echo '
<dd><code>elem</code> - the element to search.
<dd><code>result</code> - an output variable pointer. The variable will be set to the element removed from the tree.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element was removed from the tree. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_RBTREE_FUNCTIONS"><b>SGLIB_DEFINE_RBTREE_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_is_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_rbtree_type_is_member"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_is_member(<font  face="Arial" color="909090">type</font> *tree, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
determine whether an element is inside a tree. The element is searched using <a href="#comparator_equality">pointer equality</a>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_rbtree_functions_tree_parameter}"
echo '
<dd><code>elem</code> - the element to search.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>Non-zero if the element is in the tree. Zero otherwise.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_RBTREE_FUNCTIONS"><b>SGLIB_DEFINE_RBTREE_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_find_member</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_rbtree_type_find_member"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_find_member(<font  face="Arial" color="909090">type</font> *tree, <font  face="Arial" color="909090">type</font> *elem)</b></code>
<br>
<br>
find an element in the tree. The element is searched using <a href="#comparator_equality">comparator equality</a>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_rbtree_functions_tree_parameter}"
echo '
<dd><code>elem</code> - the element to search.
'
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The member of the tree <a href="#comparator_equality">comparator equal</a> to <code>elem</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_RBTREE_FUNCTIONS"><b>SGLIB_DEFINE_RBTREE_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font  face="Arial" color="909090">type</font>_len</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_rbtree_type_len"></a>
<code><b>int sglib_<font  face="Arial" color="909090">type</font>_len(<font  face="Arial" color="909090">type</font> *tree)</b></code>
<br>
<br>
compute the length of a tree, i.e. compute how many elements is inside.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_rbtree_functions_tree_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The number of elements in the <code>tree</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_RBTREE_FUNCTIONS"><b>SGLIB_DEFINE_RBTREE_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>











<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_init</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_rbtree_type_it_init"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_init(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it, <font  face="Arial" color="909090">type</font> *tree)</b></code>
<br>
<br>
initialize an iterator <code>it</code> to run over elements of <code>tree</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sglib_rbtree_container_iterator_parameter='
<dd><code>it</code> - the iterator.
'
echo "${sglib_rbtree_container_iterator_parameter}"
echo "${sglib_rbtree_functions_tree_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The first iterated element or <code>NULL</code> if there is no element.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_RBTREE_FUNCTIONS"><b>SGLIB_DEFINE_RBTREE_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>






<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_init_on_equal</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_rbtree_type_it_init_on_equal"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_init_on_equal(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it, <font  face="Arial" color="909090">type</font> *tree, int (*subcomparator)(<font  face="Arial" color="909090">type</font> *, <font  face="Arial" color="909090">type</font> *), <font  face="Arial" color="909090">type</font> *equalto)</b></code>
<br>
<br>
initialize an iterator <code>it</code> to run over those elements of the <code>tree</code> which are
equal to <code>equalto</code>. The equality is considered with respect to the 
<code>subcomparator</code> which must be a <a href="#subcomparator">subcomparator</a> 
of the <font  face="Arial" size=-1 color="909090">comparator</font>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_rbtree_container_iterator_parameter}"
echo "${sglib_rbtree_functions_tree_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<dd><code>subcomparator</code> - the comparator used to find equal elements.
<dd><code>equalto</code> - the element used as filter.
</dt>
<dt><b>Returns:</b>
<dd>The first iterated element or <code>NULL</code> if there is no element equal to <code>equalto</code>.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_RBTREE_FUNCTIONS"><b>SGLIB_DEFINE_RBTREE_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>








<tr><td VALIGN="top" WIDTH="1%">
<code><b>sglib_<font face="Arial" color="909090">type</font>_it_next</b></code>
</td><td VALIGN="top" WIDTH="1%"><i>function</i></b>
</td><td VALIGN="top" WIDTH="70%">
<a name="sglib_rbtree_type_it_next"></a>
<code><b><font  face="Arial" color="909090">type</font> *sglib_<font  face="Arial" color="909090">type</font>_it_next(struct sglib_<font  face="Arial" color="909090">type</font>_iterator *it)</b></code>
<br>
<br>
get the next element from the iterator <code>it</code>.
<dd><dl>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_rbtree_container_iterator_parameter}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
<dt><b>Returns:</b>
<dd>The next iterated element or <code>NULL</code> if there is no next element.
</dt>
<hr size=1 width=70%>
<font  face="Arial" size=-1 color="909090">
<dt>Generated by <a href="#SGLIB_DEFINE_RBTREE_FUNCTIONS"><b>SGLIB_DEFINE_RBTREE_FUNCTIONS</b></a>
<dt><b>Parameters:</b>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
echo "${sglib_define_rbtree_functions_parameters}"
#SPARSE_SHELL_SCRIPT_EXECUTE_END
</dt>
</font>
</td></tr>


</table>

</td></tr>
</table>



<br><br>
<br><br>











#SPARSE_SHELL_SCRIPT_EXECUTE
######################################################################################################################
######################################################################################################################
######################################################################################################################
######################################################################################################################
################################                   ARRAY SAMPLES                ######################################
######################################################################################################################
######################################################################################################################
######################################################################################################################
######################################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END

<a name="examples"></a>

<br><br>
<h2>Simple Examples</h2>


<a name="array_exam"></a>

<br><br>
<h2>Arrays samples</h2>

<center>

<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sed -e "s/</\\\&lt;/g" ../samples/arraysort.c
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<pre>
</td></tr>
</table>

<br>
<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sed -e "s/</\\\&lt;/g" ../samples/arraysort1.c
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<pre>
</td></tr>
</table>

<br>
<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sed -e "s/</\\\&lt;/g" ../samples/arraybinsearch.c
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<pre>
</td></tr>
</table>

</center>


#SPARSE_SHELL_SCRIPT_EXECUTE
######################################################################################################################
################################              ALL LISTS SAMPLES                #######################################
######################################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END


<a name="list_exam"></a>

<br><br>
<h2>List Sample</h2>

<center>

<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sed -e "s/</\\\&lt;/g" ../samples/listsort.c
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<pre>
</td></tr>
</table>

</center>

<a name="sorted_list_exam"></a>

<br><br>
<h2>Sorted List Samples</h2>


<center>
<br>
<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sed -e "s/</\\\&lt;/g" ../samples/listinsertsort.c
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<pre>
</td></tr>
</table>

<br>
<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sed -e "s/</\\\&lt;/g" ../samples/listinsertsort1.c
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<pre>
</td></tr>
</table>

</center>

<a name="dl_list_exam"></a>

<br><br>
<h2>Double Linked List Sample</h2>


<center>
<br>
<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sed -e "s/</\\\&lt;/g" ../samples/dllist.c
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<pre>
</td></tr>
</table>

</center>



#SPARSE_SHELL_SCRIPT_EXECUTE
######################################################################################################################
################################              HASHED CONTAINER SAMPLES                ################################
######################################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END


<a name="hashed_container_exam"></a>

<br><br>
<h2>Hashed Container Sample</h2>

<center>

<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sed -e "s/</\\\&lt;/g" ../samples/hash.c
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<pre>
</td></tr>
</table>

</center>



#SPARSE_SHELL_SCRIPT_EXECUTE
######################################################################################################################
################################              RED-BLACK TREE LISTS SAMPLES                ############################
######################################################################################################################
#SPARSE_SHELL_SCRIPT_EXECUTE_END


<a name="rbtree_exam"></a>

<br><br>
<h2>Red Black Tree Sample</h2>


<center>
<br>
<table width=90% border=1 CELLPADDING="10" CELLSPACING="1">
<tr><td>
<pre>
#SPARSE_SHELL_SCRIPT_EXECUTE_AND_INCLUDE_STDOUT
sed -e "s/</\\\&lt;/g" ../samples/rbtree.c
#SPARSE_SHELL_SCRIPT_EXECUTE_END
<pre>
</td></tr>
</table>

</center>





</body>
</html>
